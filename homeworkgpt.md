### 1. 简述堆区和栈区的区别
| 方面         | 栈区（Stack）             | 堆区（Heap）                            |
| ---------- | --------------------- | ----------------------------------- |
| **内存分配方式** | 由系统自动分配和释放（函数调用时自动管理） | 由程序员手动分配和释放（malloc/free或new/delete） |
| **生命周期**   | 随函数调用结束自动释放           | 由程序员控制，直到手动释放或程序结束才释放               |
| **分配效率**   | 快（连续内存，按顺序分配）         | 相对慢（需维护管理数据结构，分配可能不连续）              |
| **存储内容**   | 存放局部变量、函数参数、返回地址等     | 存放动态分配的对象或变量                        |
| **大小限制**   | 受限（通常较小，操作系统设定栈大小）    | 通常较大，只受系统总内存限制                      |
| **访问方式**   | 由CPU自动维护（如栈指针寄存器）     | 通过指针间接访问                            |
| **错误风险**   | 栈溢出（stack overflow）   | 内存泄漏、碎片化                            |
### 2. 野指针的可能原因和避免方法

**野指针**指向一块无效或已释放的内存区域，使用野指针会导致程序崩溃或不可预期行为。

**常见原因：**

* 指针未初始化，直接使用。
* 指针所指向的内存已被释放（如 `free` 后继续使用）。
* 指针越界访问（指向了数组或内存块边界外）。
* 指针指向了局部变量的地址，但变量已超出作用域。

**避免方法：**

* 初始化指针（比如初始化为 `NULL`）。
* 使用完毕后将指针置为 `NULL`，避免悬空。
* 小心管理内存，确保释放后不再访问。
* 使用安全的指针操作，避免越界。
* 推荐使用智能指针（C++）或容器（如 `std::vector`）管理内存。

---

### 3. 分析程序运行后的输出结果

```c
int main()
{
    int arr[5] = {1, 2, 3, 4, 5};
    int* ptr1 = (int*)(&arr + 0x1);
    int* ptr2 = (int*)((int)arr + 0x1);
    printf("%x,%x", ptr1[-1], *ptr2);
    return 0;
}
```

**分析：**

* `arr` 是长度为5的整型数组，假设 `arr` 在内存中地址是 `A`。

* `&arr` 是整个数组的地址，类型是 `int (*)[5]`，大小是 5 \* sizeof(int)，比如20字节。

* `&arr + 0x1` 表示跳过一个 `int[5]` 数组的大小，即地址变为 `A + 20`。

* 把它转换为 `int*`，即指向 `A + 20` 位置。

* `ptr1[-1]` 表示 `ptr1` 前一个 `int`，即 `*(ptr1 - 1)`，指向 `A + 16` 的整数，正好是 `arr[4] = 5`。

* `ptr2 = (int*)((int)arr + 0x1);`

  * 这里把数组首地址强制转换为 `int`（地址），加1字节，再转换成 `int*`。

  * 因为加的是1字节（不是sizeof(int)的整数倍），所以 `ptr2` 指向的地址不是4字节对齐的整型起始地址，指针类型不对齐，解引用是未定义行为。

  * 但从二进制角度来看，`*ptr2` 会读取 `arr` 起始地址的4字节中的部分数据，结果是“乱码”，不确定值。

* `printf` 以 `%x` 打印十六进制整数。

---

**结果：**

* `ptr1[-1]` 是 `arr[4]`，值为5，打印为 `5`。

* `*ptr2` 是未对齐访问，打印的是一个不确定的整数值（内存碎片数据）。

---

### 3. 为什么用枚举而不是 `#define` 定义常量？

| 方面      | `#define`        | 枚举 (`enum`)       |
| ------- | ---------------- | ----------------- |
| 类型检查    | 无，预处理宏替换，没有类型安全  | 有，枚举成员有具体类型，编译时检查 |
| 调试信息    | 无，调试时看不到名字，只看到数字 | 有，调试时能看到枚举符号名称    |
| 作用域     | 全局替换，可能污染全局命名空间  | 作用域在枚举类型内，避免冲突    |
| 可读性和维护性 | 纯文本替换，维护不方便      | 可读性更好，维护更方便       |

---

**总结**：
用枚举定义常量更安全、更规范，也方便调试和代码维护。尤其是在需要一组相关常量时，枚举更清晰。
